import React, { useState } from 'react';
import { Tool } from '@/types';
import { RealTimeDataHandoffService, DataHandoffResult } from '@/services/RealTimeDataHandoffService';
import './DataHandoffTestPanel.css';

interface DataHandoffTestPanelProps {
  tool: Tool;
  onTestResult?: (result: DataHandoffResult) => void;
}

interface TestDataEntry {
  fieldName: string;
  fieldType: string;
  value: string;
}

export const DataHandoffTestPanel: React.FC<DataHandoffTestPanelProps> = ({ 
  tool, 
  onTestResult 
}) => {
  const [testData, setTestData] = useState<TestDataEntry[]>(() => {
    if (tool.fields) {
      return tool.fields.map(field => ({
        fieldName: field.name,
        fieldType: field.type,
        value: ''
      }));
    }
    return [];
  });

  const [testResult, setTestResult] = useState<DataHandoffResult | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [useAutoGeneratedData, setUseAutoGeneratedData] = useState(true);

  const generateTestDataForField = (fieldType: string): string => {
    switch (fieldType) {
      case 'text':
        return 'Test Value';
      case 'email':
        return 'test@example.com';
      case 'phone':
        return '+1-555-123-4567';
      case 'number':
        return '123';
      case 'date':
        return new Date().toISOString().split('T')[0];
      case 'select':
        return 'Option 1';
      default:
        return 'Test Value';
    }
  };

  const handleFieldValueChange = (index: number, value: string) => {
    const updatedTestData = [...testData];
    updatedTestData[index].value = value;
    setTestData(updatedTestData);
  };

  const handleAutoGenerateData = () => {
    const autoGeneratedData = testData.map(entry => ({
      ...entry,
      value: generateTestDataForField(entry.fieldType)
    }));
    setTestData(autoGeneratedData);
  };

  const handleTestConfiguration = async () => {
    if (!tool.dataHandoff) {
      const errorResult: DataHandoffResult = {
        success: false,
        message: 'No data handoff configuration found for this tool'
      };
      setTestResult(errorResult);
      onTestResult?.(errorResult);
      return;
    }

    setIsLoading(true);
    setTestResult(null);

    try {
      let testPayload: Record<string, any> = {};

      if (useAutoGeneratedData) {
        // Use the service's built-in test data generation
        testPayload = {};
      } else {
        // Use custom test data
        testData.forEach(entry => {
          if (entry.value) {
            testPayload[entry.fieldName] = entry.value;
          }
        });
      }

      const result = await RealTimeDataHandoffService.testHandoffConfiguration(
        tool,
        useAutoGeneratedData ? undefined : testPayload
      );

      setTestResult(result);
      onTestResult?.(result);
    } catch (error: any) {
      const errorResult: DataHandoffResult = {
        success: false,
        message: `Test failed: ${error.message}`,
        errors: [error.message]
      };
      setTestResult(errorResult);
      onTestResult?.(errorResult);
    } finally {
      setIsLoading(false);
    }
  };

  const renderTestDataInputs = () => {
    if (useAutoGeneratedData) {
      return (
        <div className="test-data-auto">
          <p className="test-data-info">
            Auto-generated test data will be used based on your tool's field types.
          </p>
        </div>
      );
    }

    return (
      <div className="test-data-custom">
        <h4>Custom Test Data</h4>
        {testData.map((entry, index) => (
          <div key={entry.fieldName} className="test-field-input">
            <label>
              {entry.fieldName} ({entry.fieldType}):
            </label>
            <input
              type="text"
              value={entry.value}
              onChange={(e) => handleFieldValueChange(index, e.target.value)}
              placeholder={`Enter test value for ${entry.fieldName}`}
            />
          </div>
        ))}
      </div>
    );
  };

  const renderTestResult = () => {
    if (!testResult) return null;

    return (
      <div className={`test-result ${testResult.success ? 'success' : 'error'}`}>
        <h4>Test Result</h4>
        
        <div className="result-status">
          <span className="result-icon">
            {testResult.success ? '✅' : '❌'}
          </span>
          <span className="result-message">{testResult.message}</span>
        </div>

        {testResult.transmissionTime && (
          <div className="result-detail">
            <strong>Response Time:</strong> {testResult.transmissionTime}ms
          </div>
        )}

        {testResult.responseData && (
          <div className="result-detail">
            <strong>Response Data:</strong>
            <pre className="result-data">
              {JSON.stringify(testResult.responseData, null, 2)}
            </pre>
          </div>
        )}

        {testResult.errors && testResult.errors.length > 0 && (
          <div className="result-errors">
            <strong>Errors:</strong>
            <ul>
              {testResult.errors.map((error, index) => (
                <li key={index}>{error}</li>
              ))}
            </ul>
          </div>
        )}
      </div>
    );
  };

  const renderHandoffInfo = () => {
    if (!tool.dataHandoff) {
      return (
        <div className="handoff-info no-config">
          <p>No data handoff configuration found for this tool.</p>
          <p>Please configure data handoff in the tool settings first.</p>
        </div>
      );
    }

    return (
      <div className="handoff-info">
        <h4>Data Handoff Configuration</h4>
        <div className="config-detail">
          <strong>Type:</strong> {tool.dataHandoff.type}
        </div>
        
        {tool.dataHandoff.type === 'api' && tool.dataHandoff.api && (
          <div className="config-details">
            <div className="config-detail">
              <strong>Endpoint:</strong> {tool.dataHandoff.api.endpoint}
            </div>
            <div className="config-detail">
              <strong>Method:</strong> {tool.dataHandoff.api.method}
            </div>
          </div>
        )}
        
        {tool.dataHandoff.type === 'database' && tool.dataHandoff.database && (
          <div className="config-details">
            <div className="config-detail">
              <strong>Database:</strong> {tool.dataHandoff.database.type}
            </div>
            <div className="config-detail">
              <strong>Host:</strong> {tool.dataHandoff.database.hostname}
            </div>
            <div className="config-detail">
              <strong>Table:</strong> {tool.dataHandoff.database.table}
            </div>
          </div>
        )}
      </div>
    );
  };

  return (
    <div className="data-handoff-test-panel">
      <div className="panel-header">
        <h3>Test Data Handoff Configuration</h3>
        <p>Test your data handoff settings before using them in live voice sessions.</p>
      </div>

      {renderHandoffInfo()}

      {tool.dataHandoff && (
        <>
          <div className="test-options">
            <h4>Test Options</h4>
            
            <div className="option-toggle">
              <label className="toggle-label">
                <input
                  type="radio"
                  name="dataMode"
                  checked={useAutoGeneratedData}
                  onChange={() => setUseAutoGeneratedData(true)}
                />
                Use Auto-Generated Test Data
              </label>
            </div>
            
            <div className="option-toggle">
              <label className="toggle-label">
                <input
                  type="radio"
                  name="dataMode"
                  checked={!useAutoGeneratedData}
                  onChange={() => setUseAutoGeneratedData(false)}
                />
                Use Custom Test Data
              </label>
            </div>
          </div>

          {renderTestDataInputs()}

          {!useAutoGeneratedData && (
            <div className="data-actions">
              <button
                type="button"
                onClick={handleAutoGenerateData}
                className="btn btn-secondary"
              >
                Auto-Fill Sample Data
              </button>
            </div>
          )}

          <div className="test-actions">
            <button
              type="button"
              onClick={handleTestConfiguration}
              disabled={isLoading}
              className="btn btn-primary"
            >
              {isLoading ? 'Testing...' : 'Test Configuration'}
            </button>
          </div>

          {renderTestResult()}
        </>
      )}
    </div>
  );
};

export default DataHandoffTestPanel;
